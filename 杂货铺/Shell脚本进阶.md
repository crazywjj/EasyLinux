





# Shell脚本进阶



# Shell变量的赋值



```
在shell中变量的赋值有五种 ：使用 read 命令，直接赋值，使用命令行参数，使用命令行的输出结果，从文件读取

1. 直接赋值，格式为：变量名 = 变量值

2.Read 命令是系统内置命令，语法格式为： read  变量 1   变量 2

3. 使用命令行参数赋值：  $ 命令   参数 1   参数 2  参数 3

4. 利用命令的输出结果赋值：
currentdir=`pwd`  
echo $currentdir

5. 从文件中读入数据：
#!/bin/bash
ls *.sh >execfile
while read LINE
do
chmod a+x $LINE
done<execfile
```





# Shell变量扩展${}

**概述**
在 Shell 中 $ 字符可以用于参数扩展，算术扩展和命令替换。可以根据需要使用它来操作和扩展变量，而无需使用 sed、awk 等外部命令。



```
语法
声明变量的语法如下：

# 语法
变量名=变量值
# 示例
msg="hello world"
获取变量值的语法如下：

# 语法一，使用引号引起来是为了避免因为变量中有空格导致出现错误
echo "$变量名"
# 示例一
echo "$msg"

# 语法二，printf 命令也可以输出内容，但不会自动换行，需要通过转义符 \n 进行换行
printf "$变量名"
# 示例
printf "$msg\n"

如果要对变量进行扩展，就可以使用 ${} 语法，格式如下：
# 语法，不进行变量扩展时等价于 "$变量名"
${变量名}
# 示例
echo "${msg}"

```



## 设置变量默认值

语法
为变量设置默认值有两种语法，如下：

```
语法一
echo ${变量名:-默认值}

示例一
echo ${var1:-"hello world"}

语法二
echo ${变量名:=默认值}

示例二
echo ${var2:="hello shell"}
```

这两种语法的区别如下：

- `${变量名:-默认值}` 不会将默认值赋给变量名所表示的变量。
- `echo ${变量名:=默认值}` 会将默认值赋给变量名所表示的变量。



`{var:-default}` 与 `{var:=default}` 的区别，关于两种语法的区别，如下：

|                     条件                     | `{var:-default}` | `{var:=default}` |
| :------------------------------------------: | ---------------- | ---------------- |
|            当变量 `var` 不存在时             | 返回默认值       | 返回默认值       |
|         当变量 `var` 值为空字符串时          | 返回默认值       | 返回默认值       |
|       赋默认值后是否对变量 `var` 赋值        | 否               | 是               |
| 是否可对脚本中的位置参数 `1`、`2` 等进行设置 | 可以             | 不可以           |
|          当变量存在值时是否修改原值          | 不修改           | 不修改           |



- `${VAR:-string}` 如果VAR变量为空则返回string
- `${VAR:+string}` 如果VAR变量不为空则返回string
- `${VAR:=string}` 如果VAR变量为空则重新赋值VAR变量值为string
- `${VAR:?string} `如果VAR变量为空则将string输出到stderr



```
[root@localhost ~]# var=
[root@localhost ~]# 
[root@localhost ~]# echo ${var:=12345}
12345
[root@localhost ~]# echo $var
12345
```



## 检测变量是否定义

我们可以设置如果变量未定义或者位置参数未传递，则可以用如下语法停止执行脚本，以免报错。命令格式如下：

```bash
# 语法
# 如果变量未定义
${变量名?变量未定义输出的提示信息}
# 如果变量未定义或者为空字符串
${变量名:?变量未定义输出的提示信息}
# 未传递位置参数，通常用在脚本或函数中
${位置参数名:?未传递位置参数输出的提示信息}

# 示例
# 如果变量未定义
res=${msg?"变量未定义"}
# 如果变量未定义或者为空字符串
res=${msg:?"变量未定义或为空"}
# 未传递位置参数，通常用在脚本或函数中，$1、$2 等表示接收第 1、2 个参数
res=${1:?"未传递位置参数"}
# 提示信息中也可以使用变量扩展
info="未定义的变量"
```



## 查找字符串长度

如果要查找一个字符串变量的长度，语法格式如下：

```
# 语法
${#变量名}

# 示例
msg="hello world"
len=${#msg}
echo $len
```





## 移除模式

可以移除字符串变量中前面的子串（从前往后）。语法格式如下：

```bash
# 语法：可以从变量前面开始移除匹配模式匹配到的所有字符
# 删除匹配模式匹配到的最短部分，非贪婪匹配
${变量名#匹配模式}
# 删除匹配模式匹配到的最长部分，贪婪匹配
${变量名##匹配模式}

# 示例，获取路径所表示的文件后缀
path="/root/src/tar/test.tar.gz"
echo "${path#*.}" # 非贪婪匹配，* 属于通配符，匹配第一个 . 字符前面的所有内容，即会删除第一个 . 字符之前的所有内容，包括 . 字符本身
# 示例，只获取如下路径所表示的文件名
path="/root/src/tar/test.tar.gz"
echo "${path##*/}" # 贪婪匹配，* 属于通配符，匹配最后一个 / 字符前面的所有内容，即会删除最后一个 / 字符之前的所有内容，包括 / 字符本身
```



可以移除字符串变量中后面的子串（从后往前）。语法格式如下：

```bash
# 语法：可以从变量后面开始移除匹配模式匹配到的所有字符
# 删除匹配模式匹配到的最短部分，非贪婪匹配
${变量名%匹配模式}
# 删除匹配模式匹配到的最长部分，贪婪匹配
${变量名%%匹配模式}

# 示例，获取路径所表示的文件父目录
path="/root/src/tar/test.tar.gz"
echo "${path%/*.tar.gz}" # 非贪婪匹配，* 属于通配符，匹配 /test.tar.gz，会删除该字符串获取到该文件的父目录
# 示例，只获取所表示的文件名而去除掉后缀
file="test.tar.gz"
echo "${file%%.*}" # 贪婪匹配，* 属于通配符，会从后往前找到最后一个 . 字符，然后删除 . 字符及之后的所有字符，留下文件名
```

## 查找和替换

可以查找到旧字符串然后替换成新字符串（可以替代 `sed` 命令）。语法格式如下：

```bash
# 语法，只会替换第一次匹配成功的字符串
${变量名/旧字符串匹配模式/新字符串}
# 语法，替换所有匹配成功的字符串
${变量名//旧字符串匹配模式/新字符串}

# 示例
var="hello world, hello linux."
# 替换变量 var 中的 hello 为 HELLO
out=${var/hello/HELLO}
echo $out
echo $var
# 替换变量 var 中的 world 为 java
out=${var/world/java}
echo $out
echo $var
# 替换变量 var 中的所有 hello 为 HELLO
out=${var//hello/HELLO}
echo $out
echo $var
# 对文件进行重命名
path="/root/test.txt"
cp "${path}" "${path/.txt/.txt.bak}"
```

注：会返回修改后的结果，而不是对原变量进行修改。



## 提取子串

还可以提取子串，表示从 `offset` 指定的字符开始扩展到参数的最大长度字符。语法格式如下：

```bash
# 语法
# 提取从第 offset 个字符开始到字符串结尾的所有字符
${parameter:offset} 
# 提取从第 offset 个字符开始的 length 个字符
${parameter:offset:length} 
${variable:position} 

# 示例1，去除多余的斜线
file="/data.tar.gz"
echo ${file:1}
# 示例2，提取指定个数的字符
name="www.baidu.com"
echo ${name:4:5}
```

注：`offset` 是从字符串的第 1 个字符开始的。



## 获取匹配的变量名列表

可以获取名称以指定前缀开头的所有变量名称。语法格式如下：

```
# 语法
${!指定变量前缀匹配模式}

# 示例
name1="唐僧"
name2="孙悟空"
name3="猪八戒"
echo "${!name*}"
```



## 转换大小写

可以将字母转换成大写或小写。语法格式如下：

```bash
# 语法，将第一个字符转换为大写
${变量名^}
# 语法，将所有字母都转换成大写
${变量名^^}
# 语法，将第一个字符转换为小写
${变量名,}
# 语法，将所有字母都转换成小写
${变量名,,}
# 语法，仅转换第一个字符为小写
${变量名,指定第一个字符}

# 示例，将第一个字符转换为大写
msg="hello"
echo ${msg^}
# 示例，将所有字母都转换成大写
echo ${msg^^}
# 示例，将第一个字符转换为小写
msg="HELLO"
echo ${msg,}
# 示例，将所有字母都转换成小写
echo ${msg,,}
# 示例，仅第一个字符是 H 则转换它
echo ${msg,H}
```

## 总结

所有方便的 bash 参数替换运算符如下表：

获取默认 shell 变量值

| 语法                            | 说明                                     |
| ------------------------------- | ---------------------------------------- |
| `${parameter:-defaultValue}`    | 设置默认 shell 变量值                    |
| `${parameter:?"Error Message"}` | 如果未设置参数，则显示错误消息           |
| `${#var}`                       | 查找字符串的长度                         |
| `${var%pattern}`                | 从最短的后端（末端）模式中移除           |
| `${var%%pattern}`               | 从最长的后端（末端）图案中移除           |
| `${var:num1:num2}`              | 子串                                     |
| `${var#pattern}`                | 从最短的正面图案中移除                   |
| `${var##pattern}`               | 从最长的正面图案中移除                   |
| `${var/pattern/string}`         | 查找和替换（仅替换第一次出现）           |
| `${var//pattern/string}`        | 查找并替换所有匹配项                     |
| `${!prefix*}`                   | 扩展到名称以前缀开头的变量的名称         |
| `${var,}`                       | 将第一个字符转换为小写。                 |
| `${var,pattern}`                | 如果匹配成功，才将第一个字符转换为小写。 |
| `${var,,}`                      | 将所有字符转换为小写。                   |
| `${var,,pattern}`               | 如果匹配成功，才将所有字符转换为小写。   |
| `${var^}`                       | 将第一个字符转换为大写。                 |
| `${var^pattern}`                | 如果匹配成功，才将第一个字符转换为大写。 |
| `${var^^}`                      | 将所有字符转换为大写。                   |
| `${var^^pattern}`               | 如果匹配成功，才将所有字符转换为大写。   |

参考资料：

- [How To Use Bash Parameter Substitution Like A Pro](https://www.cyberciti.biz/tips/bash-shell-parameter-substitution-2.html)







# Shell之普通数组(列表)和关联数组(字典)



**数组相关概述**

- **变量：**存储单个元素的内存空间

- **数组：**存储多个元素的连续的内存空间，相当于多个变量的集合

**数组名和索引**
　　**索引：**编号从0开始，属于数值索引
　　**注意：**索引可支持使用自定义的格式，而不仅是数值格式，即为关联索引，bash4.0版本之后开始支持(关联数据使用时必须提前声明类型)　　bash的数组支持稀疏格式（索引不连续）

**声明数组：**

```
declare -a ARRAY_NAME
declare -A ARRAY_NAME（关联数组）
```

注意：普通数组不用事先声明就可以使用，但关联数组必须提前声明才能使用，且两者不可相互转换。



- 定义一个字典名称

```bash
declare -A ipaddress
```

- 赋值

```bash
ipaddress=([master1]="10.1.90.181" [master2]="10.1.90.182" [master3]="10.1.90.183" [node1]="10.1.90.184" [node2]="10.1.90.185" [node3]="10.1.90.186")
```

- 获取Key值 echo ${![*]}

```bash
[root@master1 ~]# echo ${!ipaddress[*]}
master2 master3 master1 node1 node2 node3
```

- 获取Value值

```bash
[root@master1 ~]# echo ${ipaddress[*]}
10.1.90.182 10.1.90.183 10.1.90.181 10.1.90.184 10.1.90.185 10.1.90.186
```

- 通过key获取值

```bash
[root@master1 ~]# echo ${ipaddress[master1]}
10.1.90.181
```